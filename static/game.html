<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Royaka - Tower Battle</title>
    <style>
      :root {
        --primary-color: #4a90e2;
        --secondary-color: #50b883;
        --accent-color: #f5b84d;
        --background-color: #f5f7fa;
        --card-color: #ffffff;
        --text-color: #3c4858;
        --border-color: #e5e9f2;
        --mana-color: #5e91f2;
        --health-color: #50b883;
        --warning-color: #f5b84d;
        --danger-color: #ec5f67;
        --shield-color: #9b59b6;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(
          135deg,
          rgba(86, 103, 255, 0.8) 0%,
          rgba(255, 138, 101, 0.8) 100%
        );
        color: var(--text-color);
        height: 100vh;
      }

      .header {
        text-align: center;
        padding: 20px 0;
        background-color: var(--card-color);
        border-bottom: 2px solid var(--border-color);
        position: relative;
      }

      .title {
        font-size: 2rem;
        margin: 0;
        color: var(--primary-color);
        text-shadow: 0 0 10px rgba(74, 144, 226, 0.2);
      }

      .subtitle {
        font-size: 1rem;
        margin: 5px 0 0;
        color: var(--text-color);
        opacity: 0.7;
      }

      .game-container {
        display: flex;
        justify-content: space-between;
        flex-direction: row;
        padding: 20px;
      }

      .stats-bar {
        display: flex;
        justify-content: space-between;
        background-color: var(--card-color);
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      }

      .stat {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      .stat-value.mana {
        color: var(--mana-color);
      }

      .stat-value.turn {
        color: var(--accent-color);
      }

      .player-stats,
      .opponent-stats {
        display: flex;
      }

      .battle-container {
        display: flex;
        width: 50vw;
        flex-direction: column;
      }

      .battlefield {
        display: flex;
        margin-bottom: 20px;
      }

      .player-side {
        flex-direction: column;
        display: flex;
        justify-content: center;
        padding: 20px;
        overflow: hidden;
        align-items: center;
        width: 80%;
      }

      .player-name {
        font-weight: bold;
        padding: 5px 10px;
        background-color: var(--primary-color);
        display: inline-block;
        margin-bottom: 10px;
        color: white;
      }

      .tower-container {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        width: 100%;
      }

      .towers {
        display: flex;
        justify-content: space-around;
        width: 100%;
      }

      .tower {
        width: 5rem;
        height: 5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .tower.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .tower.king {
        align-items: center;
        width: 6rem;
        height: 6rem;
      }

      .tower-icon {
        font-size: 3rem;
        color: var(--text-color);
      }

      .tower.king .tower-icon {
        font-size: 4rem;
      }

      .tower-name {
        font-size: 0.85rem;
        font-weight: bold;
        color: var(--text-color);
      }

      .tower-hp {
        position: absolute;
        bottom: 2px;
        left: 0;
        right: 0;
        text-align: center;
        font-size: 0.8rem;
        color: var(--text-color);
      }

      .hp-bar {
        height: 8px;
        width: 80%;
        background-color: #e5e9f2;
        border-radius: 4px;
        margin: 2px auto 0;
        overflow: hidden;
      }

      .hp-fill {
        height: 100%;
        background-color: var(--health-color);
        transition: width 0.3s ease;
      }

      .shield-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        background-color: var(--shield-color);
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        font-size: 0.8rem;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .shield-indicator.active {
        opacity: 1;
      }

      .tower-status {
        position: absolute;
        top: -10px;
        left: 50%;
        transform: translateX(-50%);
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: bold;
        background-color: var(--danger-color);
        color: white;
        opacity: 0;
        transition: all 0.3s ease;
      }

      .tower-status.show {
        opacity: 1;
        animation: status-float 1.5s forwards;
      }

      @keyframes status-float {
        0% {
          top: -10px;
          opacity: 0;
        }
        20% {
          opacity: 1;
        }
        100% {
          top: -30px;
          opacity: 0;
        }
      }

      .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text-color);
      }

      .mana-display {
        display: flex;
        align-items: center;
        padding: 5px 10px;
        background-color: rgba(94, 145, 242, 0.1);
        border-radius: 4px;
      }

      .mana-icon {
        margin-right: 5px;
        color: var(--mana-color);
      }

      .mana-value {
        font-weight: bold;
        color: var(--mana-color);
      }

      .troop-selection {
        display: flex;
        justify-content: space-between;
      }

      .troop {
        background-color: var(--card-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
      }

      .troop.selected {
        border: 2px solid var(--accent-color);
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(245, 184, 77, 0.3);
      }

      .troop.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .troop-icon {
        font-size: 2rem;
        margin-bottom: 5px;
        filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.1));
        color: var(--text-color);
      }

      .troop-name {
        font-size: 0.8rem;
        font-weight: bold;
        text-align: center;
        color: var(--text-color);
      }

      .troop-stats {
        font-size: 0.7rem;
        margin-top: 5px;
        text-align: center;
        line-height: 1.3;
        color: var(--text-color);
      }

      .troop-mana-cost {
        position: absolute;
        bottom: -15px;
        background-color: var(--mana-color);
        color: white;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        font-weight: bold;
      }

      .ability-description {
        position: absolute;
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
        width: 11vw;
        background-color: var(--card-color);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 8px;
        font-size: 0.75rem;
        z-index: 10;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s, bottom 0.3s;
        color: var(--text-color);
      }

      .troop:hover .ability-description {
        opacity: 30;
      }

      .special-actions {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        overflow-x: auto;
        padding-bottom: 5px;
      }

      .special-action {
        flex: 0 0 120px;
        background-color: var(--card-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .special-action:hover {
        background-color: #f5f7fa;
      }

      .special-action.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .special-action-icon {
        font-size: 1.5rem;
        margin-bottom: 5px;
        color: var(--text-color);
      }

      .special-action-name {
        font-size: 0.75rem;
        font-weight: bold;
        text-align: center;
        color: var(--text-color);
      }

      .special-action-cost {
        font-size: 0.7rem;
        color: var(--mana-color);
        margin-top: 3px;
      }

      .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-attack {
        background-color: var(--danger-color);
        flex: 1;
        margin-right: 10px;
      }

      .btn-attack:hover {
        background-color: #e64d43;
        transform: translateY(-2px);
      }

      .btn-attack:disabled {
        background-color: #d1d5db;
        cursor: not-allowed;
        transform: none;
      }

      .btn-end-turn {
        background-color: var(--primary-color);
        flex: 0 0 120px;
        margin-right: 10px;
      }

      .btn-end-turn:hover {
        background-color: #3a80d2;
        transform: translateY(-2px);
      }

      .btn-leave {
        background-color: #94a3b8;
        flex: 0 0 120px;
      }

      .btn-leave:hover {
        background-color: #64748b;
        transform: translateY(-2px);
      }

      .log-container {
        background: rgba(229, 233, 242, 0.5);
        border-radius: 8px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 0.9rem;
        width: 19.5vw;
        padding: 20px;
      }

      .log-entry {
        padding: 5px 0;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.9rem;
        color: var(--text-color);
      }

      .log-entry .timestamp {
        color: var(--primary-color);
        margin-right: 8px;
      }

      .log-entry .type {
        color: var(--secondary);
        margin-right: 8px;
        font-weight: bold;
      }

      .log-entry .system {
        color: var(--primary-color);
      }

      .log-entry .attack {
        color: var(--accent-color);
      }

      .log-entry .critical {
        color: var(--danger-color);
        font-weight: bold;
      }

      .log-entry .ability {
        color: var(--shield-color);
      }

      .log-entry .mana {
        color: var(--mana-color);
      }

      .notification {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--primary-color);
        color: white;
        padding: 10px 20px;
        border-radius: 4px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        z-index: 100;
        max-width: 80%;
        text-align: center;
      }

      .notification.show {
        opacity: 1;
        visibility: visible;
      }

      .game-over-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
      }

      .game-over-modal.show {
        opacity: 1;
        visibility: visible;
      }

      .modal-content {
        background-color: var(--card-color);
        border-radius: 8px;
        padding: 30px;
        text-align: center;
        max-width: 400px;
        width: 90%;
        color: var(--text-color);
      }

      .modal-title {
        font-size: 1.8rem;
        margin-bottom: 20px;
        color: var(--primary-color);
      }

      .modal-body {
        margin-bottom: 25px;
      }

      .exp-gain {
        font-size: 1.2rem;
        margin: 15px 0;
        color: var(--health-color);
      }

      .stats-summary {
        background-color: rgba(0, 0, 0, 0.02);
        border-radius: 4px;
        padding: 15px;
        margin: 15px 0;
        text-align: left;
      }

      .modal-buttons {
        display: flex;
        justify-content: center;
      }

      .btn-primary {
        background-color: var(--primary-color);
        padding: 12px 30px;
      }

      .btn-primary:hover {
        background-color: #3a80d2;
        transform: translateY(-2px);
      }

      .animation-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        overflow: hidden;
      }

      .attack-projectile {
        position: absolute;
        width: 20px;
        height: 20px;
        background-color: white;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
      }

      .damage-number {
        position: absolute;
        font-weight: bold;
        font-size: 1.5rem;
        transform: translate(-50%, -50%);
        animation: damage-float 1.5s forwards;
        z-index: 15;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      }

      .damage-number.normal {
        color: var(--text-color);
      }

      .damage-number.critical {
        color: var(--danger-color);
        font-size: 1.8rem;
      }

      @keyframes damage-float {
        0% {
          opacity: 0;
          margin-top: 0;
        }
        20% {
          opacity: 1;
        }
        100% {
          opacity: 0;
          margin-top: -40px;
        }
      }

      .shield-effect {
        position: absolute;
        border-radius: 50%;
        border: 5px solid var(--shield-color);
        box-shadow: 0 0 20px var(--shield-color);
        animation: shield-pulse 1s infinite;
        z-index: 5;
      }

      @keyframes shield-pulse {
        0% {
          opacity: 0.7;
          transform: scale(1);
        }
        50% {
          opacity: 0.3;
          transform: scale(1.1);
        }
        100% {
          opacity: 0.7;
          transform: scale(1);
        }
      }

      .progress-dot {
        width: 10px;
        height: 10px;
        background-color: #94a3b8;
        border-radius: 50%;
        margin: 0 5px;
      }

      .progress-dot.active {
        background-color: var(--primary-color);
      }

      .progress-bar {
        width: 100%;
        height: 10px;
        background: rgba(229, 233, 242, 0.5);
        border-radius: 10px;
        margin: 10px 0;
        overflow: hidden;
      }

      .progress {
        height: 100%;
        background: var(--primary-color);
        border-radius: 10px;
        width: 45%;
        transition: width 0.5s ease;
      }

      .difficulty-selection {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin: 20px 0;
      }

      .difficulty-btn {
        background-color: var(--card-color);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 10px 20px;
        color: var(--text-color);
        cursor: pointer;
        transition: all 0.2s;
      }

      .difficulty-btn.easy {
        border-bottom: 3px solid var(--health-color);
      }

      .difficulty-btn.medium {
        border-bottom: 3px solid var(--warning-color);
      }

      .difficulty-btn.hard {
        border-bottom: 3px solid var(--danger-color);
      }

      .difficulty-btn:hover {
        transform: translateY(-2px);
      }

      .difficulty-btn.selected {
        background-color: var(--primary-color);
        color: white;
      }

      @media (max-width: 100vw) {
        .battle-container {
          flex-direction: column;
          width: 50vw;
        }

        .battlefield {
          flex-direction: column;
          display: flex;
          justify-content: space-between;
          width: 50vw;
          height: 65vh;
          background-color: var(--card-color);
          margin-bottom: 8px;
          border-radius: 8px;
          align-items: center;
        }

        .tower {
          width: 5rem;
          height: 5rem;
        }

        .tower .king {
          width: 5vh;
          height: 5vh;
        }

        .troop {
          width: 10vw;
          height: 13vw;
        }

        .troop-icon {
          font-size: 5vw;
        }

        .troop-stats {
          font-size: 0.6rem;
        }

        .special-actions {
          flex-wrap: wrap;
          justify-content: space-around;
        }

        .special-action {
          flex: 0 0 calc(50% - 15px);
          margin-bottom: 10px;
        }

        .stats-bar {
          width: 19.5vw;
          display: flex;
          flex-direction: column;
          align-items: center;
        }

        .user-avatar,
        .opponent-avatar {
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: #e5e9f2;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-right: 10px;
          font-weight: bold;
          color: var(--text-color);
        }

        .stat-column {
          display: flex;
          flex-direction: column;
        }

        .stat {
          margin: 2px 0;
        }

        .stat-label {
          font-size: 12px;
          color: #64748b;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="stats-bar">
        <div class="player-stats">
          <div class="user-avatar" id="user-avatar">P</div>
          <div class="stat-column">
            <div class="stat">
              <div class="stat-label">Name:</div>
              <div class="stat-value name" id="user-name">User</div>
            </div>
            <div class="stat">
              <div class="stat-label">Level:</div>
              <div class="stat-value" id="user-level">5</div>
            </div>
          </div>
        </div>

        <div class="stat turn-display">
          <div class="stat-label">Turn</div>
          <div class="stat-value turn" id="turn-counter">1</div>
        </div>

        <div class="opponent-stats">
          <div class="opponent-avatar" id="opponent-avatar">O</div>
          <div class="stat-column">
            <div class="stat">
              <div class="stat-label">Name:</div>
              <div class="stat-value name" id="opponent-name">Opponent</div>
            </div>
            <div class="stat">
              <div class="stat-label">Level:</div>
              <div class="stat-value" id="opponent-level">5</div>
            </div>
          </div>
        </div>
      </div>

      <div class="battle-container">
        <div class="battlefield">
          <!-- Opponent Side -->
          <div class="player-side opponent" id="opponent-side">
            <!-- King Tower -->
            <div class="tower king" id="opponent-king" data-target="king">
              <div class="tower-icon">üëë</div>
              <!-- <div class="tower-name">King Tower</div> -->
              <div class="tower-hp">
                <div class="hp-bar">
                  <div
                    class="hp-fill"
                    id="opponent-king-hp-fill"
                    style="width: 100%"
                  ></div>
                </div>
              </div>
              <div class="shield-indicator" id="opponent-king-shield">0</div>
              <div class="tower-status" id="opponent-king-status"></div>
            </div>
            <div class="tower-container">
              <!-- Guard Towers -->
              <div class="towers">
                <div class="tower" id="opponent-guard1" data-target="guard1">
                  <div class="tower-icon">üõ°Ô∏è</div>
                  <!-- <div class="tower-name">Guard 1</div> -->
                  <div class="tower-hp">
                    <div class="hp-bar">
                      <div
                        class="hp-fill"
                        id="opponent-guard1-hp-fill"
                        style="width: 100%"
                      ></div>
                    </div>
                  </div>
                  <div class="shield-indicator" id="opponent-guard1-shield">
                    0
                  </div>
                  <div class="tower-status" id="opponent-guard1-status"></div>
                </div>

                <div class="tower" id="opponent-guard2" data-target="guard2">
                  <div class="tower-icon">üõ°Ô∏è</div>
                  <!-- <div class="tower-name">Guard 2</div> -->
                  <div class="tower-hp">
                    <div class="hp-bar">
                      <div
                        class="hp-fill"
                        id="opponent-guard2-hp-fill"
                        style="width: 100%"
                      ></div>
                    </div>
                  </div>
                  <div class="shield-indicator" id="opponent-guard2-shield">
                    0
                  </div>
                  <div class="tower-status" id="opponent-guard2-status"></div>
                </div>
              </div>
            </div>
            <div class="animation-container" id="opponent-animations"></div>
          </div>

          <!-- Player Side -->
          <div class="player-side" id="player-side">
            <div class="tower-container">
              <!-- Guard Towers -->
              <div class="towers">
                <div class="tower" id="player-guard1">
                  <div class="tower-icon">üõ°Ô∏è</div>
                  <!-- <div class="tower-name">Guard 1</div> -->
                  <div class="tower-hp">
                    <div class="hp-bar">
                      <div
                        class="hp-fill"
                        id="player-guard1-hp-fill"
                        style="width: 100%"
                      ></div>
                    </div>
                  </div>
                  <div class="shield-indicator" id="player-guard1-shield">
                    0
                  </div>
                  <div class="tower-status" id="player-guard1-status"></div>
                </div>

                <div class="tower" id="player-guard2">
                  <div class="tower-icon">üõ°Ô∏è</div>
                  <!-- <div class="tower-name">Guard 2</div> -->
                  <div class="tower-hp">
                    <div class="hp-bar">
                      <div
                        class="hp-fill"
                        id="player-guard2-hp-fill"
                        style="width: 100%"
                      ></div>
                    </div>
                  </div>
                  <div class="shield-indicator" id="player-guard1-shield">
                    0
                  </div>
                  <div class="tower-status" id="player-guard1-status"></div>
                </div>
              </div>

              <div class="animation-container" id="player-animations"></div>
            </div>
            <!-- King Tower -->
            <div class="tower king" id="player-king">
              <div class="tower-hp">
                <div class="hp-bar">
                  <div
                    class="hp-fill"
                    id="player-king-hp-fill"
                    style="width: 100%"
                  ></div>
                </div>
              </div>
              <div class="tower-icon">üëë</div>
              <!-- <div class="tower-name">King Tower</div> -->
              <div class="shield-indicator" id="player-king-shield">0</div>
              <div class="tower-status" id="player-king-status"></div>
            </div>
          </div>
        </div>
        <div class="controls">
          <div class="troops-container">
            <div class="section-header">
              <div class="progress-bar">
                <div class="progress" id="expProgress"></div>
              </div>
            </div>

            <div class="troop-selection">
              <div class="troop" id="archer" data-cost="3">
                <div class="troop-icon">üèπ</div>
                <div class="troop-name">Archer</div>
                <div class="troop-mana-cost">3</div>
                <div class="ability-description">
                  Attacks from a distance with increased critical chance.
                </div>
              </div>

              <div class="troop" id="knight" data-cost="4">
                <div class="troop-icon">‚öîÔ∏è</div>
                <div class="troop-name">Knight</div>
                <div class="troop-mana-cost">4</div>
                <div class="ability-description">
                  Strong melee attacker with high damage and health.
                </div>
              </div>

              <div class="troop" id="mage" data-cost="5">
                <div class="troop-icon">üîÆ</div>
                <div class="troop-name">Mage</div>
                <div class="troop-mana-cost">5</div>
                <div class="ability-description">
                  Deals splash damage to multiple towers.
                </div>
              </div>

              <div class="troop" id="healer" data-cost="4">
                <div class="troop-icon">‚ú®</div>
                <div class="troop-name">Healer</div>
                <div class="troop-mana-cost">4</div>
                <div class="ability-description">
                  Restores health to your towers.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="log-container" id="log-container">
        <div class="log-entry">
          <span id="timestamp" class="timestamp"></span>
          <span class="type">SYSTEM</span>
          <span class="message">Welcome to Royaka!</span>
        </div>
        <div id="log"></div>
      </div>

      <div class="notification" id="notification">
        <span id="notification-text"></span>
      </div>

      <div class="game-over-modal" id="game-over-modal">
        <div class="modal-content">
          <h2 class="modal-title" id="result-title">Victory!</h2>
          <div class="modal-body">
            <p id="result-message">You have defeated your opponent!</p>
            <div class="exp-gain" id="exp-gain">+100 XP</div>

            <div class="stats-summary">
              <div class="stat-row">
                <span class="stat-label">Turns Played:</span>
                <span class="stat-value" id="stats-turns">12</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Damage Dealt:</span>
                <span class="stat-value" id="stats-damage">3500</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Mana Spent:</span>
                <span class="stat-value" id="stats-mana">45</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Critical Hits:</span>
                <span class="stat-value" id="stats-crits">4</span>
              </div>
            </div>
          </div>
          <div class="modal-buttons">
            <button class="btn btn-primary" id="play-again-btn">
              Play Again
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      let socket = null;
      let user, opponent;

      function connectWebSocket() {
        socket = new WebSocket("ws://localhost:8080/ws");

        socket.onopen = () => {
          console.log("WebSocket connection established");
          const room_id = localStorage.getItem("room_id");
          const username = localStorage.getItem("username");
          console.log("Room ID:", room_id);
          socket.send(
            JSON.stringify({
              type: "get_game_info",
              data: { room_id: room_id, username: username },
            })
          );
        };

        socket.onmessage = handleSocketMessage;

        socket.onclose = () => {
          console.log(
            "WebSocket connection closed. Attempting to reconnect..."
          );
          setTimeout(connectWebSocket, 1000);
        };

        socket.onerror = () => {
          console.error("WebSocket error. Attempting to reconnect...");
          socket.close();
        };
      }

      function handleSocketMessage(event) {
        const msg = JSON.parse(event.data);
        console.log("Received message:", msg);

        if (msg.type === "game_info_response") {
          if (msg.success) {
            user = msg.data.user;
            console.log("User:", user);
            document.getElementById("user-name").innerText = user.user.username;
            document.getElementById("user-avatar").innerText =
              user.user.username.charAt(0).toUpperCase();
            document.getElementById("user-level").innerText = user.user.level;

            opponent = msg.data.opponent;
            console.log("Opponent:", opponent);
            document.getElementById("opponent-name").innerText =
              opponent.user.username;
            document.getElementById("opponent-avatar").innerText =
              opponent.user.username.charAt(0).toUpperCase();
            document.getElementById("opponent-level").innerText =
              opponent.user.level;
          } else {
            console.error("Failed to get game info:", msg.error);
            showNotification("Failed to get game info: " + msg.error);
          }
        }
      }

      connectWebSocket();

      // Game initialization and main logic would go here
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize game state
        const gameState = {
          turn: 1,
          playerMana: 5,
          maxMana: 10,
          playerHealth: {
            king: 2000,
            guard1: 1000,
            guard2: 1000,
          },
          opponentHealth: {
            king: 2000,
            guard1: 1000,
            guard2: 1000,
          },
          shields: {
            player: {
              king: 0,
              guard1: 0,
              guard2: 0,
            },
            opponent: {
              king: 0,
              guard1: 0,
              guard2: 0,
            },
          },
          selectedTroop: null,
          selectedTarget: null,
          difficulty: "medium",
          playerTurn: true,
          gameOver: false,
        };

        // DOM elements
        const elements = {
          // Player towers
          playerKing: document.getElementById("player-king"),
          playerGuard1: document.getElementById("player-guard1"),
          playerGuard2: document.getElementById("player-guard2"),
          // Opponent towers
          opponentKing: document.getElementById("opponent-king"),
          opponentGuard1: document.getElementById("opponent-guard1"),
          opponentGuard2: document.getElementById("opponent-guard2"),
          // Stats
          playerMana: document.getElementById("player-mana"),
          currentMana: document.getElementById("current-mana"),
          turnCounter: document.getElementById("turn-counter"),
          // Buttons
          attackBtn: document.getElementById("attack-btn"),
          endTurnBtn: document.getElementById("end-turn-btn"),
          // Troops
          troops: document.querySelectorAll(".troop"),
          // Other UI elements
          gameLog: document.getElementById("log-container"),
          notification: document.getElementById("notification"),
          gameOverModal: document.getElementById("game-over-modal"),
        };

        // Event listeners
        elements.endTurnBtn.addEventListener("click", endTurn);
        elements.attackBtn.addEventListener("click", performAttack);

        // Set up troops
        elements.troops.forEach((troop) => {
          troop.addEventListener("click", () => selectTroop(troop));
        });

        // Set up opponent towers as targets
        const opponentTowers = [
          elements.opponentKing,
          elements.opponentGuard1,
          elements.opponentGuard2,
        ];
        opponentTowers.forEach((tower) => {
          tower.addEventListener("click", () => selectTarget(tower));
        });

        // Special actions
        const specialActions = document.querySelectorAll(".special-action");
        specialActions.forEach((action) => {
          action.addEventListener("click", () => useSpecialAction(action));
        });

        // Game functions
        function selectTroop(troop) {
          // Clear previous selections
          elements.troops.forEach((t) => t.classList.remove("selected"));

          // Check if we have enough mana
          const cost = parseInt(troop.dataset.cost);
          if (gameState.playerMana < cost) {
            showNotification("Not enough mana!");
            return;
          }

          // Select this troop
          troop.classList.add("selected");
          gameState.selectedTroop = troop.id;

          // Update UI
          elements.attackBtn.disabled = !gameState.selectedTarget;

          // Log
          addLogEntry(
            `Selected ${troop.querySelector(".troop-name").textContent}`
          );
        }

        function selectTarget(tower) {
          // Only select if it's player's turn
          if (!gameState.playerTurn) return;

          // Clear previous selections
          opponentTowers.forEach((t) => t.classList.remove("selected"));

          // Select this tower
          tower.classList.add("selected");
          gameState.selectedTarget = tower.id;

          // Update UI
          elements.attackBtn.disabled = !gameState.selectedTroop;

          // Log
          addLogEntry(
            `Target selected: ${tower.querySelector(".tower-name").textContent}`
          );
        }

        function performAttack() {
          if (!gameState.selectedTroop || !gameState.selectedTarget) return;

          const troop = document.getElementById(gameState.selectedTroop);
          const target = document.getElementById(gameState.selectedTarget);
          const cost = parseInt(troop.dataset.cost);

          // Deduct mana
          gameState.playerMana -= cost;
          updateManaDisplay();

          // Calculate damage
          let damage = 0;
          const isCritical = Math.random() < 0.2; // 20% chance for critical hit

          switch (gameState.selectedTroop) {
            case "archer":
              damage = isCritical ? 300 : 150;
              break;
            case "knight":
              damage = isCritical ? 400 : 200;
              break;
            case "mage":
              damage = isCritical ? 360 : 180;
              break;
            case "healer":
              // Heal player towers instead
              healPlayerTowers(150);
              addLogEntry("Healer restores 150 HP to your towers", "ability");
              resetSelections();
              return;
          }

          // Apply damage
          const targetId = gameState.selectedTarget.replace("opponent-", "");
          applyDamage("opponent", targetId, damage, isCritical);

          // Animation
          animateAttack(troop, target, damage, isCritical);

          // Log
          if (isCritical) {
            addLogEntry(
              `Critical hit! ${
                troop.querySelector(".troop-name").textContent
              } deals ${damage} damage to ${
                target.querySelector(".tower-name").textContent
              }`,
              "critical"
            );
          } else {
            addLogEntry(
              `${
                troop.querySelector(".troop-name").textContent
              } deals ${damage} damage to ${
                target.querySelector(".tower-name").textContent
              }`,
              "attack"
            );
          }

          // Reset selections
          resetSelections();

          // Check for win condition
          checkWinCondition();
        }

        function applyDamage(side, towerType, damage, isCritical) {
          // Apply shield reduction if any
          const shieldValue = gameState.shields[side][towerType];
          if (shieldValue > 0) {
            if (shieldValue >= damage) {
              // Shield absorbs all damage
              gameState.shields[side][towerType] -= damage;
              showTowerStatus(side, towerType, `Shield -${damage}`);
              damage = 0;
            } else {
              // Shield absorbs part of damage
              damage -= shieldValue;
              showTowerStatus(side, towerType, `Shield -${shieldValue}`);
              gameState.shields[side][towerType] = 0;
            }

            // Update shield display
            updateShieldDisplay(side, towerType);
          }

          // Apply remaining damage to health
          if (damage > 0) {
            gameState[side + "Health"][towerType] -= damage;

            // Make sure health doesn't go below 0
            if (gameState[side + "Health"][towerType] < 0) {
              gameState[side + "Health"][towerType] = 0;
            }

            // Show damage number
            showDamageNumber(side, towerType, damage, isCritical);

            // Update health display
            updateHealthDisplay(side, towerType);
          }
        }

        function healPlayerTowers(amount) {
          // Heal all player towers
          for (const towerType in gameState.playerHealth) {
            // Only heal if tower is not at full health
            const maxHealth = towerType === "king" ? 2000 : 1000;

            if (gameState.playerHealth[towerType] < maxHealth) {
              gameState.playerHealth[towerType] += amount;

              // Cap at max health
              if (gameState.playerHealth[towerType] > maxHealth) {
                gameState.playerHealth[towerType] = maxHealth;
              }

              // Show healing number
              showTowerStatus("player", towerType, `+${amount} HP`, "health");

              // Update health display
              updateHealthDisplay("player", towerType);
            }
          }
        }

        function updateHealthDisplay(side, towerType) {
          const element = document.getElementById(`${side}-${towerType}-hp`);
          const fillElement = document.getElementById(
            `${side}-${towerType}-hp-fill`
          );

          if (element && fillElement) {
            const currentHealth = gameState[side + "Health"][towerType];
            const maxHealth = towerType === "king" ? 2000 : 1000;
            const percentage = (currentHealth / maxHealth) * 100;

            element.textContent = currentHealth;
            fillElement.style.width = `${percentage}%`;

            // Change color based on health percentage
            if (percentage < 25) {
              fillElement.style.backgroundColor = "var(--danger-color)";
            } else if (percentage < 50) {
              fillElement.style.backgroundColor = "var(--warning-color)";
            }
          }
        }

        function updateShieldDisplay(side, towerType) {
          const element = document.getElementById(
            `${side}-${towerType}-shield`
          );
          if (element) {
            const shieldValue = gameState.shields[side][towerType];
            element.textContent = shieldValue;

            if (shieldValue > 0) {
              element.classList.add("active");
            } else {
              element.classList.remove("active");
            }
          }
        }

        function updateManaDisplay() {
          elements.playerMana.textContent = `${gameState.playerMana}/${gameState.maxMana}`;
          elements.currentMana.textContent = gameState.playerMana;

          // Update troops availability based on mana
          elements.troops.forEach((troop) => {
            const cost = parseInt(troop.dataset.cost);
            if (gameState.playerMana < cost) {
              troop.classList.add("disabled");
            } else {
              troop.classList.remove("disabled");
            }
          });

          // Update special actions availability
          document.querySelectorAll(".special-action").forEach((action) => {
            const cost = parseInt(action.dataset.cost);
            if (gameState.playerMana < cost) {
              action.classList.add("disabled");
            } else {
              action.classList.remove("disabled");
            }
          });
        }

        function endTurn() {
          if (!gameState.playerTurn) return;

          gameState.playerTurn = false;
          addLogEntry("Turn ended. Opponent's turn...", "system");

          // Disable controls during opponent turn
          togglePlayerControls(false);

          // Highlight active side
          document.getElementById("player-side").classList.remove("active");
          document.getElementById("opponent-side").classList.add("active");

          // AI opponent turn (simulated)
          setTimeout(() => {
            opponentTurn();
          }, 1500);
        }

        function opponentTurn() {
          // Simple AI implementation
          const aiAction = Math.random();

          if (aiAction < 0.7) {
            // Attack
            const targets = ["king", "guard1", "guard2"];
            const targetIndex = Math.floor(Math.random() * targets.length);
            const targetType = targets[targetIndex];

            // Choose attack type based on difficulty
            let damage = 0;
            let attackName = "";

            switch (gameState.difficulty) {
              case "easy":
                damage = Math.floor(Math.random() * 100) + 50; // 50-150 damage
                attackName = "Weak Attack";
                break;
              case "medium":
                damage = Math.floor(Math.random() * 150) + 100; // 100-250 damage
                attackName = "Normal Attack";
                break;
              case "hard":
                damage = Math.floor(Math.random() * 200) + 150; // 150-350 damage
                attackName = "Strong Attack";
                break;
            }

            // Apply damage
            applyDamage("player", targetType, damage, false);

            // Log
            addLogEntry(
              `Opponent uses ${attackName} and deals ${damage} damage to your ${
                targetType === "king"
                  ? "King Tower"
                  : "Guard Tower " + targetType.charAt(targetType.length - 1)
              }`,
              "attack"
            );

            // Animation
            const opponentTower = document.getElementById("opponent-king");
            const playerTower = document.getElementById(`player-${targetType}`);
            animateAttack(opponentTower, playerTower, damage, false);
          } else if (aiAction < 0.9) {
            // Use shield on random tower
            const targets = ["king", "guard1", "guard2"];
            const targetIndex = Math.floor(Math.random() * targets.length);
            const targetType = targets[targetIndex];

            // Add shield based on difficulty
            let shieldAmount = 0;

            switch (gameState.difficulty) {
              case "easy":
                shieldAmount = 100;
                break;
              case "medium":
                shieldAmount = 200;
                break;
              case "hard":
                shieldAmount = 300;
                break;
            }

            gameState.shields.opponent[targetType] += shieldAmount;
            updateShieldDisplay("opponent", targetType);

            // Animation
            showShieldEffect("opponent", targetType);

            // Log
            addLogEntry(
              `Opponent adds ${shieldAmount} shield to their ${
                targetType === "king"
                  ? "King Tower"
                  : "Guard Tower " + targetType.charAt(targetType.length - 1)
              }`,
              "ability"
            );
          } else {
            // Heal
            let healAmount = 0;

            switch (gameState.difficulty) {
              case "easy":
                healAmount = 100;
                break;
              case "medium":
                healAmount = 150;
                break;
              case "hard":
                healAmount = 200;
                break;
            }

            // Find lowest health tower
            let lowestHealth = 9999;
            let lowestTower = null;

            for (const towerType in gameState.opponentHealth) {
              const maxHealth = towerType === "king" ? 2000 : 1000;
              if (
                gameState.opponentHealth[towerType] < maxHealth &&
                gameState.opponentHealth[towerType] < lowestHealth
              ) {
                lowestHealth = gameState.opponentHealth[towerType];
                lowestTower = towerType;
              }
            }

            if (lowestTower) {
              const maxHealth = lowestTower === "king" ? 2000 : 1000;
              gameState.opponentHealth[lowestTower] += healAmount;

              if (gameState.opponentHealth[lowestTower] > maxHealth) {
                gameState.opponentHealth[lowestTower] = maxHealth;
              }

              updateHealthDisplay("opponent", lowestTower);
              showTowerStatus(
                "opponent",
                lowestTower,
                `+${healAmount} HP`,
                "health"
              );

              // Log
              addLogEntry(
                `Opponent heals their ${
                  lowestTower === "king"
                    ? "King Tower"
                    : "Guard Tower " +
                      lowestTower.charAt(lowestTower.length - 1)
                } for ${healAmount} HP`,
                "ability"
              );
            } else {
              // If no tower needs healing, do an attack instead
              const targetType =
                targets[Math.floor(Math.random() * targets.length)];
              const damage = Math.floor(Math.random() * 150) + 100;

              applyDamage("player", targetType, damage, false);

              // Log
              addLogEntry(
                `Opponent attacks your ${
                  targetType === "king"
                    ? "King Tower"
                    : "Guard Tower " + targetType.charAt(targetType.length - 1)
                } for ${damage} damage`,
                "attack"
              );

              // Animation
              const opponentTower = document.getElementById("opponent-king");
              const playerTower = document.getElementById(
                `player-${targetType}`
              );
              animateAttack(opponentTower, playerTower, damage, false);
            }
          }

          // Check for win condition
          if (checkWinCondition()) return;

          // Start next turn
          startNewTurn();
        }

        function startNewTurn() {
          gameState.turn++;
          gameState.playerTurn = true;

          // Update turn counter
          elements.turnCounter.textContent = gameState.turn;

          // Replenish some mana
          gameState.playerMana = Math.min(
            gameState.maxMana,
            gameState.playerMana + 3
          );
          updateManaDisplay();

          // Enable controls
          togglePlayerControls(true);

          // Highlight active side
          document.getElementById("opponent-side").classList.remove("active");
          document.getElementById("player-side").classList.add("active");

          // Log
          addLogEntry(`Turn ${gameState.turn} - Your turn!`, "system");
        }

        function togglePlayerControls(enabled) {
          elements.troops.forEach((troop) => {
            troop.classList.toggle("disabled", !enabled);
          });

          elements.endTurnBtn.disabled = !enabled;
          elements.attackBtn.disabled = !enabled;

          document.querySelectorAll(".special-action").forEach((action) => {
            action.classList.toggle("disabled", !enabled);
          });
        }

        function resetSelections() {
          gameState.selectedTroop = null;
          gameState.selectedTarget = null;

          elements.troops.forEach((troop) => {
            troop.classList.remove("selected");
          });

          opponentTowers.forEach((tower) => {
            tower.classList.remove("selected");
          });

          elements.attackBtn.disabled = true;
        }

        function checkWinCondition() {
          if (gameState.playerHealth.king <= 0) {
            // Player lost
            showGameOverScreen(false);
            return true;
          } else if (gameState.opponentHealth.king <= 0) {
            // Player won
            showGameOverScreen(true);
            return true;
          }
          return false;
        }

        function showGameOverScreen(isVictory) {
          const resultTitle = document.getElementById("result-title");
          const resultMessage = document.getElementById("result-message");
          const expGain = document.getElementById("exp-gain");

          if (isVictory) {
            resultTitle.textContent = "Victory!";
            resultMessage.textContent = "You have defeated your opponent!";
            expGain.textContent = "+100 XP";
          } else {
            resultTitle.textContent = "Defeat";
            resultMessage.textContent = "Your kingdom has fallen!";
            expGain.textContent = "+25 XP";
          }

          // Update stats
          document.getElementById("stats-turns").textContent = gameState.turn;

          // Show modal
          elements.gameOverModal.classList.add("show");

          // Set up play again button
          document
            .getElementById("play-again-btn")
            .addEventListener("click", function () {
              location.reload();
            });
        }

        // Animation functions
        function animateAttack(source, target, damage, isCritical) {
          const sourceRect = source.getBoundingClientRect();
          const targetRect = target.getBoundingClientRect();

          const sourceX = sourceRect.left + sourceRect.width / 2;
          const sourceY = sourceRect.top + sourceRect.height / 2;
          const targetX = targetRect.left + targetRect.width / 2;
          const targetY = targetRect.top + targetRect.height / 2;

          // Create projectile
          const projectile = document.createElement("div");
          projectile.className = "attack-projectile";

          // Determine which container to use
          const container = source.id.includes("opponent")
            ? document.getElementById("opponent-animations")
            : document.getElementById("player-animations");

          container.appendChild(projectile);

          // Calculate relative coordinates
          const containerRect = container.getBoundingClientRect();
          const relSourceX = sourceX - containerRect.left;
          const relSourceY = sourceY - containerRect.top;
          const relTargetX = targetX - containerRect.left;
          const relTargetY = targetY - containerRect.top;

          // Position at source
          projectile.style.left = `${relSourceX}px`;
          projectile.style.top = `${relSourceY}px`;

          // Animate to target
          setTimeout(() => {
            projectile.style.transition = "all 0.5s ease-in-out";
            projectile.style.left = `${relTargetX}px`;
            projectile.style.top = `${relTargetY}px`;

            setTimeout(() => {
              projectile.remove();
              showDamageNumber(
                target.id.includes("opponent") ? "opponent" : "player",
                target.id.replace(/.*?-(.*?)$/, "$1"),
                damage,
                isCritical
              );
            }, 500);
          }, 10);
        }

        function showDamageNumber(side, towerType, damage, isCritical) {
          if (damage <= 0) return;

          const tower = document.getElementById(`${side}-${towerType}`);
          const towerRect = tower.getBoundingClientRect();

          const container = document.getElementById(`${side}-animations`);
          const containerRect = container.getBoundingClientRect();

          const damageNumber = document.createElement("div");
          damageNumber.className = `damage-number ${
            isCritical ? "critical" : "normal"
          }`;
          damageNumber.textContent = damage;

          container.appendChild(damageNumber);

          // Calculate relative coordinates
          const relX =
            towerRect.left + towerRect.width / 2 - containerRect.left;
          const relY = towerRect.top + towerRect.height / 2 - containerRect.top;

          damageNumber.style.left = `${relX}px`;
          damageNumber.style.top = `${relY}px`;

          setTimeout(() => {
            damageNumber.remove();
          }, 1500);
        }

        function showTowerStatus(side, towerType, text, type = "normal") {
          const statusElement = document.getElementById(
            `${side}-${towerType}-status`
          );
          if (statusElement) {
            statusElement.textContent = text;
            statusElement.className = "tower-status";

            if (type === "health") {
              statusElement.style.backgroundColor = "var(--health-color)";
            } else if (type === "shield") {
              statusElement.style.backgroundColor = "var(--shield-color)";
            }

            statusElement.classList.add("show");

            setTimeout(() => {
              statusElement.classList.remove("show");
            }, 1500);
          }
        }

        function showShieldEffect(side, towerType) {
          const tower = document.getElementById(`${side}-${towerType}`);
          const container = document.getElementById(`${side}-animations`);

          const shieldEffect = document.createElement("div");
          shieldEffect.className = "shield-effect";

          const towerRect = tower.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();

          const relX =
            towerRect.left + towerRect.width / 2 - containerRect.left;
          const relY = towerRect.top + towerRect.height / 2 - containerRect.top;
          const size = Math.max(towerRect.width, towerRect.height) * 1.2;

          shieldEffect.style.left = `${relX}px`;
          shieldEffect.style.top = `${relY}px`;
          shieldEffect.style.width = `${size}px`;
          shieldEffect.style.height = `${size}px`;
          shieldEffect.style.marginLeft = `-${size / 2}px`;
          shieldEffect.style.marginTop = `-${size / 2}px`;

          container.appendChild(shieldEffect);

          setTimeout(() => {
            shieldEffect.remove();
          }, 1000);
        }

        // Special actions
        function useSpecialAction(action) {
          const cost = parseInt(action.dataset.cost);

          if (gameState.playerMana < cost) {
            showNotification("Not enough mana!");
            return;
          }

          gameState.playerMana -= cost;
          updateManaDisplay();

          switch (action.id) {
            case "fireball":
              // Deal damage to all opponent towers
              const damage = 200;
              for (const towerType in gameState.opponentHealth) {
                applyDamage("opponent", towerType, damage, false);
              }
              addLogEntry(
                `Fireball deals ${damage} damage to all opponent towers!`,
                "ability"
              );
              break;

            case "shield":
              // Add shield to all player towers
              const shieldAmount = 300;
              for (const towerType in gameState.playerHealth) {
                gameState.shields.player[towerType] += shieldAmount;
                updateShieldDisplay("player", towerType);
                showShieldEffect("player", towerType);
              }
              addLogEntry(
                `Shield spell adds ${shieldAmount} shield to all your towers!`,
                "ability"
              );
              break;

            case "freeze":
              // Skip opponent's next turn
              addLogEntry(
                `Freeze spell prevents opponent's next action!`,
                "ability"
              );
              // In a real game, you'd need to implement this logic
              showNotification("Opponent frozen for 1 turn!");
              break;

            case "mana-boost":
              // Gain extra mana
              const manaGain = 3;
              gameState.playerMana = Math.min(
                gameState.maxMana,
                gameState.playerMana + manaGain
              );
              updateManaDisplay();
              addLogEntry(`Mana Boost restores ${manaGain} mana!`, "mana");
              break;
          }
        }

        // UI functions
        function addLogEntry(text, type = "system") {
          const now = new Date();
          const timestamp = `${now
            .getMinutes()
            .toString()
            .padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}`;

          const entry = document.createElement("div");
          entry.className = "log-entry";

          const timeSpan = document.createElement("span");
          timeSpan.className = "timestamp";
          timeSpan.textContent = timestamp;

          const textSpan = document.createElement("span");
          textSpan.className = type;
          textSpan.textContent = text;

          entry.appendChild(timeSpan);
          entry.appendChild(textSpan);

          elements.gameLog.appendChild(entry);
          elements.gameLog.scrollTop = elements.gameLog.scrollHeight;
        }

        function showNotification(text) {
          const notification = elements.notification;
          notification.querySelector("#notification-text").textContent = text;
          notification.classList.add("show");

          setTimeout(() => {
            notification.classList.remove("show");
          }, 3000);
        }

        // Initialize game
        function initGame() {
          updateManaDisplay();
          document.getElementById("player-side").classList.add("active");

          // Set player and opponent names
          document.getElementById("playerName").textContent = "Player";
          document.getElementById("opponentName").textContent = "Opponent";

          // Set initial health displays
          for (const towerType in gameState.playerHealth) {
            updateHealthDisplay("player", towerType);
          }

          for (const towerType in gameState.opponentHealth) {
            updateHealthDisplay("opponent", towerType);
          }

          // Show welcome message
          addLogEntry("Welcome to Royaka - Tower Battle!", "system");
          addLogEntry(
            "Select a troop and target, then click Attack!",
            "system"
          );
        }

        // Start the game
        initGame();
      });
    </script>
  </body>
</html>
